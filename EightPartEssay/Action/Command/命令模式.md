![](https://res.weread.qq.com/wrepub/epub_679952_47)
# 命令模式
> 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
# 命令模式有如下4个角色
- 命令（Command）角色：该角色声明一个给所有具体命令类的抽象接口，定义需要执行的命令。
- 具体命令（Concrete Command）角色：该角色定义一个接收者和行为之间的弱耦合，实现命令方法，并调用接收者的相应操作。
- 调用者（Invoker）角色：该角色负责调用命令对象执行请求。
- 接收者（Receiver）角色：该角色负责具体实施和执行一个请求。
# 命令模式的优点
- 类间解耦。调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command中的execute()方法即可，不需要了解是哪个接收者执行
- 可扩展性。Command 的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。
-  命令模式结合其他模式会更优秀。命令模式可以结合责任链模式，实现命令族解析任务，结合模板方法模式，则可以减少Command子类的膨胀问题。
# 使用命令模式的缺点如下
- 使用命令模式可能会导致系统中出现过多的具体命令类，因此需要在项目中慎重考虑使用。
# 使用场景
- 使用命令模式作为“回调”在面向对象系统中的替代。“回调”讲的便是将一个函数登记上，然后在以后调用此函数。
- 需要在不同的时间指定请求、将请求排队。
- 系统需要支持命令的撤销（undo）。命令对象可以把状态存储起来，等到客户端需要撤销时，可以调用undo()方法，将命令所产生的效果撤销。
- 需要将系统中所有的数据更新操作保存到日志里，以便在系统崩溃时，可以根据日志读回所有的数据更新命令，重新调用 execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。
- 一个系统需要支持交易（transaction）。一个交易结构封装了一组数据更新命令。使用命令模式来实现交易结构可以使系统增加新的交易类型。