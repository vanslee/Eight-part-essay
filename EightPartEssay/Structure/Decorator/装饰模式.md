![](https://res.weread.qq.com/wrepub/epub_679952_31)
# 中文介绍
动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活
装饰模式有以下四个角色
- 抽象构建角色: 该角色用于规范需要装饰的对象（原始对象）。
- 具体构建: 该角色实现抽象构件接口，定义一个需要装饰的原始类。
- 装饰: 该角色持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。
- 具体装饰: 该角色负责对构件对象进行装饰
# 装饰模式的优缺点
## 优点
- 装饰类和被装饰类可以独立发展，而不会相互耦合。即 Component 类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。
- 装饰模式是继承关系的一个替代方案。装饰类Decorator，不管装饰多少层，返回的对象还是Component。
- 装饰模式可以动态地扩展一个实现类的功能。
## 缺点
- 多层的装饰是比较复杂的。
# 装饰模式的使用场景
- 需要扩展一个类的功能，或给一个类增加附加功能。
- 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
- 需要为一批类进行改装或加装功能

**装饰模式是对继承的有力补充。单纯使用继承时，在一些情况下就会增加很多子类，而且灵活性差，维护也不容易。装饰模式可以替代继承，解决类膨胀的问题，如Java基础类库中的输入输出流相关的类大量使用了装饰模式。**